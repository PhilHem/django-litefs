# litefs-py

A Python library for seamless SQLite replication via LiteFS, with framework adapters for Django, FastAPI, and more.

## Project Vision

- **Goal**: Framework-agnostic LiteFS integration; complexity abstracted away
- **Distribution**: Core package (`litefs-py`) + framework adapters (`django-litefs`, `fastapi-litefs`)
- **Target**: Python 3.10+
- **Use Case**: Multi-node HA deployments with synchronized SQLite (Kubernetes-like HA without Kubernetes)
- **Platform**: Self-hosted (Docker Compose, VMs, bare metal) — no external services required
- **Differentiator**: Embedded Raft leader election (no Consul/Fly.io dependency)

## Package Architecture

```
PyPI Packages:
├── litefs-py           # Core (framework-agnostic, bundles LiteFS binary)
├── django-litefs       # Django adapter (depends on litefs-py)
└── fastapi-litefs      # FastAPI adapter (future, depends on litefs-py)
```

### Core vs Adapters

| Layer | Package | Framework deps | Contents |
|-------|---------|----------------|----------|
| Core | `litefs-py` | None | Config generation, Raft, health, binary |
| Django | `django-litefs` | Django 5.x | Settings reader, DB backend, commands |
| FastAPI | `fastapi-litefs` | FastAPI | Settings, middleware, routes (future) |

### Target Deployment Architecture

```
                    ┌─────────────────┐
                    │  Load Balancer  │
                    │  (nginx/traefik)│
                    └────────┬────────┘
                             │
         ┌───────────────────┼───────────────────┐
         ▼                   ▼                   ▼
┌─────────────────┐ ┌─────────────────┐ ┌─────────────────┐
│   Container 1   │ │   Container 2   │ │   Container 3   │
│   (Primary)     │ │   (Replica)     │ │   (Replica)     │
│                 │ │                 │ │                 │
│ LiteFS :8080 ───┼─│ LiteFS :8080 ───┼─│ LiteFS :8080    │
│   ↓ (proxy)     │ │   ↓ (proxy)     │ │   ↓ (proxy)     │
│ Django :8000    │ │ Django :8000    │ │ Django :8000    │
│   ↓             │ │   ↓             │ │   ↓             │
│ /litefs/db ◄────┼─┼───────◄─────────┼─┼───────◄────────│
│ (read/write)    │ │ (read-only)     │ │ (read-only)     │
└─────────────────┘ └─────────────────┘ └─────────────────┘
         │
         └──── Writes replicated to all replicas ──────┘
```

**Key points:**

- LiteFS proxy handles write forwarding automatically
- Load balancer can hit any node; writes forwarded to primary
- Single primary holds write lease; replicas sync asynchronously
- No Kubernetes required—works with Docker Compose, VMs, or bare metal

## Clean Architecture (Robert C. Martin)

This project follows Clean Architecture principles. **Flag violations when spotted.**

### Layer Structure

```
┌─────────────────────────────────────────────────────────┐
│  Frameworks & Drivers (outermost)                       │
│  - Django framework, LiteFS binary, SQLite              │
│  ┌─────────────────────────────────────────────────┐   │
│  │  Interface Adapters                              │   │
│  │  - Database backend, management commands, views  │   │
│  │  ┌─────────────────────────────────────────┐    │   │
│  │  │  Use Cases (Application Layer)          │    │   │
│  │  │  - Process management, config generation│    │   │
│  │  │  ┌─────────────────────────────────┐   │    │   │
│  │  │  │  Entities (Domain Layer)        │   │    │   │
│  │  │  │  - Settings, LiteFSConfig       │   │    │   │
│  │  │  └─────────────────────────────────┘   │    │   │
│  │  └─────────────────────────────────────────┘    │   │
│  └─────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────┘
```

### Dependency Rule

- Dependencies point **inward only**
- Inner layers know nothing about outer layers
- Domain/Entities have zero external dependencies

### Mapping to Package Structure

| Layer              | Location                                         | Contents                                             |
| ------------------ | ------------------------------------------------ | ---------------------------------------------------- |
| Entities           | `django_litefs/domain/`                          | `LiteFSSettings`, `ClusterConfig`, value objects     |
| Use Cases          | `django_litefs/usecases/`                        | `ProcessManager`, `ConfigGenerator`, `HealthChecker` |
| Interface Adapters | `django_litefs/db/`, `django_litefs/management/` | Database backend, commands                           |
| Frameworks         | `django_litefs/apps.py`, `django_litefs/bin/`    | Django integration, LiteFS binary                    |

### Violations to Flag

- ❌ Domain layer importing Django
- ❌ Use cases importing from interface adapters
- ❌ Business logic in management commands or views
- ❌ Database backend containing business rules
- ❌ Direct LiteFS process calls outside use cases

## Architectural Charter

Decisions made via structured architecture review.

| Decision Area     | Choice                                            |
| ----------------- | ------------------------------------------------- |
| Criticality       | Application-critical                              |
| Domain complexity | Moderate orchestration                            |
| Consistency model | Strong (single primary, LiteFS-dictated)          |
| Concurrency model | Thread-safe sync (Django default)                 |
| Flow style        | Configuration + Management commands               |
| State ownership   | LiteFS owns all state (no caching)                |
| Error semantics   | Django exceptions + custom LiteFS errors          |
| Retry strategy    | None (application handles)                        |
| Observability     | Logging + Django checks + Prometheus metrics      |
| Configuration     | Django settings only (`LITEFS = {...}`)           |
| Testing           | Unit + Property-Based + Integration (Docker/FUSE) |
| Versioning        | Semantic versioning strict                        |

### Key Constraints

- Dependencies point inward only (Clean Architecture)
- LiteFS is the source of truth for cluster state
- No library-level retry; exceptions propagate to application
- PBT required for config generation and settings validation
- Deprecation warnings for at least one minor version before removal

## Architecture Decisions

### Django Integration

- **Database Backend**: Custom `DatabaseWrapper` subclass of `django.db.backends.sqlite3`
- **Write Forwarding**: Handled by LiteFS proxy (HTTP layer), not database backend
- **Transaction Mode**: Enforce `IMMEDIATE` mode by default for better lock handling
- **WAL Mode**: Auto-configured (LiteFS requirement)
- **Migrations**: Only run on primary node (check via LiteFS `.primary` file)

### Process Management

- **LiteFS Lifecycle**: LiteFS is the container entrypoint; it spawns Django as a child process
- **Startup Hook**: `AppConfig.ready` validates settings and checks LiteFS availability
- **Signal Handling**: LiteFS handles SIGTERM; Django receives it via process tree
- **Health Checks**: Django exposes health endpoint that queries LiteFS for replica lag

### Leader Election (V2: Embedded Raft)

No external services required. Uses PySyncObj for Raft consensus:

```
┌─────────────────┐     ┌─────────────────┐     ┌─────────────────┐
│   Container 1   │     │   Container 2   │     │   Container 3   │
│                 │     │                 │     │                 │
│  Django + Raft ◄├─────┼► Django + Raft ◄├─────┼► Django + Raft  │
│  (Leader)       │     │  (Follower)     │     │  (Follower)     │
│       ↓         │     │       ↓         │     │       ↓         │
│  Writes .primary│     │  Reads .primary │     │  Reads .primary │
│       ↓         │     │       ↓         │     │       ↓         │
│  LiteFS (write) │     │  LiteFS (read)  │     │  LiteFS (read)  │
└─────────────────┘     └─────────────────┘     └─────────────────┘
```

**How it works:**

1. PySyncObj runs embedded in each Django process
2. Raft elects a leader (quorum-based, automatic failover)
3. Leader writes `.primary` file to signal LiteFS
4. LiteFS uses static lease mode; we manage the `.primary` file externally
5. If leader dies, Raft elects new leader within seconds

### Settings Interface

#### Core API (litefs-py)

```python
from litefs import LiteFSSettings

settings = LiteFSSettings(
    mount_path="/litefs",
    data_path="/var/lib/litefs",
    database_name="db.sqlite3",
    leader_election="static",          # "static" (V1) or "raft" (V2)
    raft_self_addr="localhost:4321",   # V2 only
    raft_peers=[],                     # V2 only
    proxy_addr=":8080",
    enabled=True,
    retention="1h",
)
```

#### Django Adapter (django-litefs)

```python
# settings.py
INSTALLED_APPS = [
    ...
    "litefs_django",
]

DATABASES = {
    "default": {
        "ENGINE": "litefs_django.db.backends.litefs",
        "NAME": "default",
    }
}

LITEFS = {
    "MOUNT_PATH": "/litefs",
    "DATA_PATH": "/var/lib/litefs",
    "DATABASE_NAME": "db.sqlite3",
    "LEADER_ELECTION": "static",       # "static" (V1) or "raft" (V2)
    "RAFT_SELF_ADDR": "localhost:4321",
    "RAFT_PEERS": [],
    "PROXY_ADDR": ":8080",
    "ENABLED": True,
    "RETENTION": "1h",
}
```

#### FastAPI Adapter (future)

```python
from litefs_fastapi import LiteFSMiddleware, get_litefs_settings
from pydantic_settings import BaseSettings

class Settings(BaseSettings):
    litefs_mount_path: str = "/litefs"
    litefs_raft_peers: list[str] = []
    # ... maps to LiteFSSettings

app.add_middleware(LiteFSMiddleware, settings=get_litefs_settings())
```

### Binary Distribution

- **Approach**: Platform-specific wheels
- **Platforms**:
  - `manylinux_2_17_x86_64`
  - `manylinux_2_17_aarch64`
  - `macosx_11_0_x86_64`
  - `macosx_11_0_arm64`
- **Build System**: `hatchling` with custom build hook
- **LiteFS Version**: Pin to specific release, document upgrade process
- **CI**: GitHub Actions builds wheels for each platform

### Config Generation

- Generate `litefs.yml` from Django settings at runtime
- Store generated config in temp directory or `DATA_PATH`
- Validate settings on Django startup

## Package Structure (Clean Architecture)

### Monorepo Layout

```
litefs-py/
├── packages/
│   ├── litefs/                        # Core package (PyPI: litefs-py)
│   │   ├── pyproject.toml
│   │   └── src/litefs/
│   │       ├── __init__.py
│   │       ├── domain/                # [Entities] Zero external deps
│   │       │   ├── __init__.py
│   │       │   ├── settings.py        # LiteFSSettings dataclass
│   │       │   ├── config.py          # ClusterConfig, DatabaseConfig
│   │       │   └── exceptions.py      # Domain exceptions
│   │       │
│   │       ├── usecases/              # [Use Cases] Application logic
│   │       │   ├── __init__.py
│   │       │   ├── config_generator.py
│   │       │   ├── health_checker.py
│   │       │   ├── primary_detector.py
│   │       │   └── leader_election.py # V2: Raft (PySyncObj)
│   │       │
│   │       ├── adapters/              # [Interface Adapters] Generic
│   │       │   ├── __init__.py
│   │       │   ├── file_writer.py
│   │       │   └── subprocess_runner.py
│   │       │
│   │       └── bin/                   # Bundled LiteFS binaries
│   │           └── .gitkeep
│   │
│   └── django-litefs/                 # Django adapter (PyPI: django-litefs)
│       ├── pyproject.toml             # depends on litefs-py
│       └── src/litefs_django/
│           ├── __init__.py
│           ├── apps.py                # AppConfig startup hooks
│           ├── settings.py            # Read from Django settings
│           ├── db/backends/litefs/    # Django database backend
│           │   ├── __init__.py
│           │   ├── base.py
│           │   ├── features.py
│           │   └── operations.py
│           └── management/commands/
│               ├── litefs_status.py
│               └── litefs_check.py
│
├── tests/
│   ├── core/                          # Tests for litefs-py
│   │   ├── unit/
│   │   └── integration/
│   └── django/                        # Tests for django-litefs
│       ├── unit/
│       └── integration/
│
├── scripts/
│   └── download_litefs.py
├── CLAUDE.md
└── README.md
```

### Future: FastAPI Adapter

```
packages/
└── fastapi-litefs/                    # PyPI: fastapi-litefs
    ├── pyproject.toml                 # depends on litefs-py
    └── src/litefs_fastapi/
        ├── __init__.py
        ├── settings.py                # Pydantic settings integration
        ├── middleware.py              # Request middleware
        └── routes.py                  # Health endpoints
```

## Adapter Resource Management

Adapters that manage resources (subprocesses, file handles) should implement the context manager protocol to ensure proper cleanup:

```python
class ProcessRunner:
    def __init__(self):
        self._process = None

    def __enter__(self) -> ProcessRunner:
        return self

    def __exit__(self, exc_type, exc_val, exc_tb) -> None:
        self.stop()

    def stop(self) -> None:
        if self._process:
            self._process.terminate()
            self._process.wait()
            self._process = None
```

## Port Method Signatures

Port methods should accept **primitive types**, not Django model instances:

```python
# ❌ Wrong - port depends on Django
class ConfigPort(Protocol):
    def generate(self, settings: django.conf.Settings) -> str: ...

# ✅ Right - port accepts domain types
class ConfigPort(Protocol):
    def generate(self, settings: LiteFSSettings) -> str: ...
```

## Roadmap

### V1: Static Primary (MVP)

- [ ] Core package structure and database backend
- [ ] Settings interface and config generation
- [ ] Static leader election (manual failover)
- [ ] Management commands (status, check)
- [ ] Unit tests with in-memory adapters

### V2: Embedded Raft Leader Election

- [ ] Integrate PySyncObj for Raft consensus
- [ ] Automatic failover without external services
- [ ] Health checks with leader status
- [ ] Integration tests with multi-node Docker Compose

### V3: Polish

- [ ] Prometheus metrics
- [ ] Development mode (single-node, no Raft)
- [ ] Documentation and examples

## Answered Questions

### LiteFS version to bundle

**Decision**: Latest stable release (currently 0.5.x series). Pin to specific version in `pyproject.toml`, document upgrade process in CHANGELOG. Check [LiteFS releases](https://github.com/superfly/litefs/releases) before initial release.

### PySyncObj vs alternatives

**Decision**: Use **PySyncObj**

- Mature library (3k+ GitHub stars)
- Pure Python, no C dependencies
- Battle-tested Raft implementation
- Supports dynamic cluster membership
- Alternatives considered: raft-py (less mature), dragonboat (Go, not Python)

### How Raft integrates with LiteFS

**Decision**: We manage the `.primary` file externally

1. LiteFS runs in `static` lease mode (no Consul)
2. PySyncObj elects a Raft leader among Django processes
3. Raft leader writes `.primary` file to LiteFS mount
4. LiteFS reads `.primary` to determine which node accepts writes
5. On leader change, new leader updates `.primary` file

This works because LiteFS's static mode just checks for the `.primary` file—it doesn't care how the file gets there.

## Open Questions

- [ ] Raft port selection (separate from Django, e.g., :4321?)
- [ ] Graceful handling of split-brain scenarios

## Build Commands

```bash
# Install dependencies
uv sync

# Run all tests (excludes integration by default)
uv run pytest

# Run specific test category
uv run pytest -m unit
uv run pytest -m integration
uv run pytest -m property

# Type checking
uv run mypy src/django_litefs/

# Linting
uv run ruff check src/django_litefs/
uv run ruff format src/django_litefs/

# Build wheels
uv run python -m build
```

### Package Management (uv only)

**Never edit `pyproject.toml` dependencies directly.** Always use uv commands:

```bash
uv add requests              # Add dependency
uv add --group dev pytest    # Add dev dependency
uv remove requests           # Remove dependency
uv lock                      # Update lock file
```

## Balancing Abstraction vs Coupling

Clean Architecture can lead to over-engineering. Use these indicators:

### Signs of unnecessary indirection

- A port with only one adapter that will never have another
- Wrapper classes that just delegate to another class
- Interfaces with a single method that could be a function
- "Manager", "Handler", "Processor" classes that don't manage state
- More than 3 layers between API request and storage

### Signs of problematic coupling

- Domain importing from `adapters/`
- Use cases importing Django
- Tests requiring LiteFS binary to run
- Changing a domain model requires updating more than 3 files

### Rules of thumb

- **No port without 2+ adapters** (or clear intent for future adapters)
- **Prefer functions over classes** for stateless operations
- **Adapters should be thin** - convert types and delegate, not implement logic
- **If unsure, start concrete** - extract abstraction when the second use case appears

## Testing Strategy

### Test Organization

```bash
# By category
pytest -m unit           # Fast, no LiteFS process
pytest -m integration    # With Docker + FUSE
pytest -m property       # Property-based tests
```

### Test Directory Structure

```
tests/
├── unit/                    # No I/O, no subprocess
│   ├── domain/              # Pure domain logic (settings, config)
│   ├── usecases/            # Use case tests with in-memory adapters
│   └── conftest.py          # In-memory adapter fixtures
├── integration/             # Requires Docker + FUSE
│   ├── test_backend.py
│   └── test_replication.py
└── conftest.py              # Shared fixtures
```

### CI Strategy

- **Unit tests**: Run on all PRs (fast, no Docker)
- **Integration tests**: Run on main branch only (requires Docker + FUSE)
- **Local testing**: Docker Compose setup mirrors integration CI

### Test Isolation Rules

**Unit tests (`tests/unit/`) must NOT:**

- Spawn subprocesses or call LiteFS binary
- Access filesystem beyond temp directories
- Require FUSE or Docker

**Unit tests SHOULD use:**

- In-memory adapter fixtures:
  - `in_memory_process_runner` → `InMemoryProcessRunner`
  - `in_memory_config_writer` → `InMemoryConfigWriter`
  - `fake_primary_detector` → `FakePrimaryDetector`

### In-Memory Adapter Pattern

```python
# tests/unit/conftest.py
@pytest.fixture
def in_memory_process_runner():
    return InMemoryProcessRunner()

# tests/unit/usecases/test_process_manager.py
def test_start_litefs(in_memory_process_runner):
    manager = ProcessManager(runner=in_memory_process_runner)
    manager.start()
    assert in_memory_process_runner.started is True
```

### Property-Based Testing (Hypothesis)

Use for config generation and settings validation:

```bash
uv run pytest -m property -v
```

**When to use:**
| Pattern | Property to Test | Example |
|---------|-----------------|---------|
| **Round-trip** | `parse(generate(x)) == x` | Config YAML generation |
| **Invariants** | Bounds always hold | Path validation |
| **Idempotence** | `f(f(x)) == f(x)` | Settings normalization |

```python
from hypothesis import given, strategies as st

@pytest.mark.property
@given(mount_path=st.text(min_size=1).filter(lambda x: x.startswith("/")))
def test_config_includes_mount_path(mount_path):
    settings = LiteFSSettings(mount_path=mount_path)
    config = ConfigGenerator().generate(settings)
    assert mount_path in config
```

## Pre-commit Hooks

```bash
uv run pre-commit install    # Install hooks
uv run pre-commit run --all-files  # Run manually
```

Hooks mirror CI: ruff check, ruff format, mypy, pytest.

**NEVER bypass pre-commit hooks with `--no-verify`.** If a hook fails:

1. Fix the issue if it's a legitimate code problem
2. Report the error if it's a hook configuration issue

## CI Parity

**CI must use identical commands to local development.** No separate CI-specific scripts. The pipeline uses `uv sync` and `uv run` exactly as developers do locally.

## Dependencies

### Core (litefs-py)

| Dependency | Required | Purpose |
|------------|----------|---------|
| pyyaml | Yes | Config generation |
| PySyncObj | V2 only | Raft leader election |
| prometheus-client | Optional | Metrics |

### Django Adapter (django-litefs)

| Dependency | Required | Purpose |
|------------|----------|---------|
| litefs-py | Yes | Core functionality |
| Django 5.x | Yes | Framework integration |

### FastAPI Adapter (fastapi-litefs) - Future

| Dependency | Required | Purpose |
|------------|----------|---------|
| litefs-py | Yes | Core functionality |
| FastAPI | Yes | Framework integration |
| pydantic-settings | Yes | Settings management |

## References

- [LiteFS Documentation](https://fly.io/docs/litefs/)
- [LiteFS GitHub](https://github.com/superfly/litefs)
- [PySyncObj](https://github.com/bakwc/PySyncObj) - Raft consensus library
- [Django Custom Database Backends](https://docs.djangoproject.com/en/5.2/ref/databases/#subclassing-the-built-in-database-backends)
