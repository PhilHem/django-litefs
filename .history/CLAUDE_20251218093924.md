# django-litefs

A Django library that provides seamless SQLite replication via LiteFS with a clean settings interface.

## Project Vision

- **Goal**: Users interact with Django settings only; LiteFS complexity is abstracted away
- **Distribution**: PyPI package bundles LiteFS binary (platform-specific wheels)
- **Target**: Django 5.x, Python 3.10+

## Clean Architecture (Robert C. Martin)

This project follows Clean Architecture principles. **Flag violations when spotted.**

### Layer Structure

```
┌─────────────────────────────────────────────────────────┐
│  Frameworks & Drivers (outermost)                       │
│  - Django framework, LiteFS binary, SQLite              │
│  ┌─────────────────────────────────────────────────┐   │
│  │  Interface Adapters                              │   │
│  │  - Database backend, management commands, views  │   │
│  │  ┌─────────────────────────────────────────┐    │   │
│  │  │  Use Cases (Application Layer)          │    │   │
│  │  │  - Process management, config generation│    │   │
│  │  │  ┌─────────────────────────────────┐   │    │   │
│  │  │  │  Entities (Domain Layer)        │   │    │   │
│  │  │  │  - Settings, LiteFSConfig       │   │    │   │
│  │  │  └─────────────────────────────────┘   │    │   │
│  │  └─────────────────────────────────────────┘    │   │
│  └─────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────┘
```

### Dependency Rule

- Dependencies point **inward only**
- Inner layers know nothing about outer layers
- Domain/Entities have zero external dependencies

### Mapping to Package Structure

| Layer              | Location                                         | Contents                                             |
| ------------------ | ------------------------------------------------ | ---------------------------------------------------- |
| Entities           | `django_litefs/domain/`                          | `LiteFSSettings`, `ClusterConfig`, value objects     |
| Use Cases          | `django_litefs/usecases/`                        | `ProcessManager`, `ConfigGenerator`, `HealthChecker` |
| Interface Adapters | `django_litefs/db/`, `django_litefs/management/` | Database backend, commands                           |
| Frameworks         | `django_litefs/apps.py`, `django_litefs/bin/`    | Django integration, LiteFS binary                    |

### Violations to Flag

- ❌ Domain layer importing Django
- ❌ Use cases importing from interface adapters
- ❌ Business logic in management commands or views
- ❌ Database backend containing business rules
- ❌ Direct LiteFS process calls outside use cases

## Architecture Decisions

### Django Integration

- **Database Backend**: Custom `DatabaseWrapper` subclass of `django.db.backends.sqlite3`
- **Write Forwarding**: Backend detects primary node and routes writes appropriately
- **Transaction Mode**: Enforce `IMMEDIATE` mode by default for better lock handling
- **WAL Mode**: Auto-configured (LiteFS requirement)
- **Migrations**: Only run on primary node (check via LiteFS primary detection)

### Process Management

- **LiteFS Lifecycle**: Django spawns and supervises LiteFS process
- **Startup Hook**: Integrate with Django's startup (AppConfig.ready or management command)
- **Signal Handling**: Graceful shutdown coordination (SIGTERM handling)
- **Health Checks**: Expose health endpoint for replica lag monitoring

### Settings Interface

```python
# settings.py
INSTALLED_APPS = [
    ...
    "django_litefs",
]

DATABASES = {
    "default": {
        "ENGINE": "django_litefs.db.backends.litefs",
        "NAME": "default",  # database name within LiteFS mount
    }
}

LITEFS = {
    # Paths
    "MOUNT_PATH": "/litefs",           # FUSE mount point (user-facing DBs)
    "DATA_PATH": "/var/lib/litefs",    # Internal LiteFS data storage

    # Database
    "DATABASE_NAME": "db.sqlite3",     # SQLite filename

    # Cluster
    "CONSUL_URL": None,                # Consul URL for leader election
    "LEASE_URL": None,                 # Fly.io lease endpoint (alternative to Consul)

    # Networking
    "PROXY_ADDR": ":8081",             # LiteFS proxy address

    # Process management
    "AUTO_START": True,                # Django manages LiteFS process
    "BINARY_PATH": None,               # Override bundled binary path

    # Replication
    "RETENTION": "1h",                 # Transaction log retention
    "RETENTION_MONITOR_INTERVAL": "1m",
}
```

### Binary Distribution

- **Approach**: Platform-specific wheels
- **Platforms**:
  - `manylinux_2_17_x86_64`
  - `manylinux_2_17_aarch64`
  - `macosx_11_0_x86_64`
  - `macosx_11_0_arm64`
- **Build System**: `hatchling` with custom build hook
- **LiteFS Version**: Pin to specific release, document upgrade process
- **CI**: GitHub Actions builds wheels for each platform

### Config Generation

- Generate `litefs.yml` from Django settings at runtime
- Store generated config in temp directory or `DATA_PATH`
- Validate settings on Django startup

## Package Structure (Clean Architecture)

```
django-litefs/
├── pyproject.toml
├── README.md
├── CLAUDE.md
├── src/
│   └── django_litefs/
│       ├── __init__.py
│       ├── apps.py                    # [Framework] AppConfig startup hooks
│       │
│       ├── domain/                    # [Entities] Zero external deps
│       │   ├── __init__.py
│       │   ├── settings.py            # LiteFSSettings dataclass
│       │   ├── config.py              # ClusterConfig, DatabaseConfig
│       │   └── exceptions.py          # Domain exceptions
│       │
│       ├── usecases/                  # [Use Cases] Application logic
│       │   ├── __init__.py
│       │   ├── process_manager.py     # Start/stop/supervise LiteFS
│       │   ├── config_generator.py    # Generate litefs.yml
│       │   ├── health_checker.py      # Check replica status
│       │   └── primary_detector.py    # Detect primary node
│       │
│       ├── adapters/                  # [Interface Adapters]
│       │   ├── __init__.py
│       │   ├── django_settings.py     # Read from Django settings
│       │   └── subprocess_runner.py   # Run LiteFS binary
│       │
│       ├── db/                        # [Interface Adapters] Django backend
│       │   └── backends/
│       │       └── litefs/
│       │           ├── __init__.py
│       │           ├── base.py        # DatabaseWrapper
│       │           ├── features.py    # DatabaseFeatures
│       │           └── operations.py
│       │
│       ├── management/                # [Interface Adapters] Commands
│       │   └── commands/
│       │       ├── litefs_start.py
│       │       ├── litefs_status.py
│       │       └── litefs_primary.py
│       │
│       └── bin/                       # [Framework] Bundled binaries
│           └── .gitkeep
│
├── tests/
│   ├── conftest.py
│   ├── unit/
│   │   ├── domain/
│   │   │   └── test_settings.py
│   │   └── usecases/
│   │       ├── test_config_generator.py
│   │       └── test_process_manager.py
│   └── integration/
│       ├── test_backend.py
│       └── test_replication.py
└── scripts/
    └── download_litefs.py             # CI script to fetch binaries
```

## Testing Strategy

- **Unit tests**: Mock LiteFS process, test settings parsing, config generation
- **Integration tests**: Require Docker with FUSE support, marked with `@pytest.mark.integration`
- **CI**: Unit tests on all PRs, integration tests on main branch
- **Local testing**: Docker Compose setup with FUSE device mount

## Open Questions

- [ ] Exact LiteFS version to bundle initially
- [ ] Should we support non-Fly.io Consul setups?
- [ ] Management command vs AppConfig.ready for process startup
- [ ] How to handle development mode (single node, no replication)?

## Commands

```bash
# Install dependencies
pip install -e ".[dev]"

# Run tests
pytest -m "not integration"

# Run integration tests (requires Docker)
pytest -m integration

# Build wheels
python -m build
```

## References

- [LiteFS Documentation](https://fly.io/docs/litefs/)
- [LiteFS GitHub](https://github.com/superfly/litefs)
- [Django Custom Database Backends](https://docs.djangoproject.com/en/5.2/ref/databases/#subclassing-the-built-in-database-backends)
