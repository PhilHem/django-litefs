# django-litefs

A Django library that provides seamless SQLite replication via LiteFS with a clean settings interface.

## Project Vision

- **Goal**: Users interact with Django settings only; LiteFS complexity is abstracted away
- **Distribution**: PyPI package bundles LiteFS binary (platform-specific wheels)
- **Target**: Django 5.x, Python 3.10+
- **Use Case**: Multi-node HA deployments with synchronized SQLite (Kubernetes-like HA without Kubernetes)
- **Platform**: Self-hosted (Docker Compose, VMs, bare metal) — no external services required
- **Differentiator**: Embedded Raft leader election (no Consul/Fly.io dependency)

### Target Deployment Architecture

```
                    ┌─────────────────┐
                    │  Load Balancer  │
                    │  (nginx/traefik)│
                    └────────┬────────┘
                             │
         ┌───────────────────┼───────────────────┐
         ▼                   ▼                   ▼
┌─────────────────┐ ┌─────────────────┐ ┌─────────────────┐
│   Container 1   │ │   Container 2   │ │   Container 3   │
│   (Primary)     │ │   (Replica)     │ │   (Replica)     │
│                 │ │                 │ │                 │
│ LiteFS :8080 ───┼─│ LiteFS :8080 ───┼─│ LiteFS :8080    │
│   ↓ (proxy)     │ │   ↓ (proxy)     │ │   ↓ (proxy)     │
│ Django :8000    │ │ Django :8000    │ │ Django :8000    │
│   ↓             │ │   ↓             │ │   ↓             │
│ /litefs/db ◄────┼─┼───────◄─────────┼─┼───────◄────────│
│ (read/write)    │ │ (read-only)     │ │ (read-only)     │
└─────────────────┘ └─────────────────┘ └─────────────────┘
         │
         └──── Writes replicated to all replicas ──────┘
```

**Key points:**

- LiteFS proxy handles write forwarding automatically
- Load balancer can hit any node; writes forwarded to primary
- Single primary holds write lease; replicas sync asynchronously
- No Kubernetes required—works with Docker Compose, VMs, or bare metal

## Clean Architecture (Robert C. Martin)

This project follows Clean Architecture principles. **Flag violations when spotted.**

### Layer Structure

```
┌─────────────────────────────────────────────────────────┐
│  Frameworks & Drivers (outermost)                       │
│  - Django framework, LiteFS binary, SQLite              │
│  ┌─────────────────────────────────────────────────┐   │
│  │  Interface Adapters                              │   │
│  │  - Database backend, management commands, views  │   │
│  │  ┌─────────────────────────────────────────┐    │   │
│  │  │  Use Cases (Application Layer)          │    │   │
│  │  │  - Process management, config generation│    │   │
│  │  │  ┌─────────────────────────────────┐   │    │   │
│  │  │  │  Entities (Domain Layer)        │   │    │   │
│  │  │  │  - Settings, LiteFSConfig       │   │    │   │
│  │  │  └─────────────────────────────────┘   │    │   │
│  │  └─────────────────────────────────────────┘    │   │
│  └─────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────┘
```

### Dependency Rule

- Dependencies point **inward only**
- Inner layers know nothing about outer layers
- Domain/Entities have zero external dependencies

### Mapping to Package Structure

| Layer              | Location                                         | Contents                                             |
| ------------------ | ------------------------------------------------ | ---------------------------------------------------- |
| Entities           | `django_litefs/domain/`                          | `LiteFSSettings`, `ClusterConfig`, value objects     |
| Use Cases          | `django_litefs/usecases/`                        | `ProcessManager`, `ConfigGenerator`, `HealthChecker` |
| Interface Adapters | `django_litefs/db/`, `django_litefs/management/` | Database backend, commands                           |
| Frameworks         | `django_litefs/apps.py`, `django_litefs/bin/`    | Django integration, LiteFS binary                    |

### Violations to Flag

- ❌ Domain layer importing Django
- ❌ Use cases importing from interface adapters
- ❌ Business logic in management commands or views
- ❌ Database backend containing business rules
- ❌ Direct LiteFS process calls outside use cases

## Architectural Charter

Decisions made via structured architecture review.

| Decision Area     | Choice                                            |
| ----------------- | ------------------------------------------------- |
| Criticality       | Application-critical                              |
| Domain complexity | Moderate orchestration                            |
| Consistency model | Strong (single primary, LiteFS-dictated)          |
| Concurrency model | Thread-safe sync (Django default)                 |
| Flow style        | Configuration + Management commands               |
| State ownership   | LiteFS owns all state (no caching)                |
| Error semantics   | Django exceptions + custom LiteFS errors          |
| Retry strategy    | None (application handles)                        |
| Observability     | Logging + Django checks + Prometheus metrics      |
| Configuration     | Django settings only (`LITEFS = {...}`)           |
| Testing           | Unit + Property-Based + Integration (Docker/FUSE) |
| Versioning        | Semantic versioning strict                        |

### Key Constraints

- Dependencies point inward only (Clean Architecture)
- LiteFS is the source of truth for cluster state
- No library-level retry; exceptions propagate to application
- PBT required for config generation and settings validation
- Deprecation warnings for at least one minor version before removal

## Architecture Decisions

### Django Integration

- **Database Backend**: Custom `DatabaseWrapper` subclass of `django.db.backends.sqlite3`
- **Write Forwarding**: Handled by LiteFS proxy (HTTP layer), not database backend
- **Transaction Mode**: Enforce `IMMEDIATE` mode by default for better lock handling
- **WAL Mode**: Auto-configured (LiteFS requirement)
- **Migrations**: Only run on primary node (check via LiteFS `.primary` file)

### Process Management

- **LiteFS Lifecycle**: LiteFS is the container entrypoint; it spawns Django as a child process
- **Startup Hook**: `AppConfig.ready` validates settings and checks LiteFS availability
- **Signal Handling**: LiteFS handles SIGTERM; Django receives it via process tree
- **Health Checks**: Django exposes health endpoint that queries LiteFS for replica lag

### Settings Interface

```python
# settings.py
INSTALLED_APPS = [
    ...
    "django_litefs",
]

DATABASES = {
    "default": {
        "ENGINE": "django_litefs.db.backends.litefs",
        "NAME": "default",  # database name within LiteFS mount
    }
}

LITEFS = {
    # Paths
    "MOUNT_PATH": "/litefs",           # FUSE mount point (user-facing DBs)
    "DATA_PATH": "/var/lib/litefs",    # Internal LiteFS data storage

    # Database
    "DATABASE_NAME": "db.sqlite3",     # SQLite filename

    # Leader election
    "LEADER_ELECTION": "static",       # "static" (V1) or "raft" (V2)
    "RAFT_PEERS": [],                  # V2: List of peer addresses for Raft cluster
    "RAFT_SELF_ADDR": None,            # V2: This node's address for Raft

    # Networking
    "PROXY_ADDR": ":8080",             # LiteFS proxy address (load balancer connects here)

    # Runtime mode
    "ENABLED": True,                   # False = bypass LiteFS, use regular SQLite (dev mode)
    "BINARY_PATH": None,               # Override bundled binary path (for custom LiteFS builds)

    # Replication
    "RETENTION": "1h",                 # Transaction log retention
    "RETENTION_MONITOR_INTERVAL": "1m",
}
```

### Binary Distribution

- **Approach**: Platform-specific wheels
- **Platforms**:
  - `manylinux_2_17_x86_64`
  - `manylinux_2_17_aarch64`
  - `macosx_11_0_x86_64`
  - `macosx_11_0_arm64`
- **Build System**: `hatchling` with custom build hook
- **LiteFS Version**: Pin to specific release, document upgrade process
- **CI**: GitHub Actions builds wheels for each platform

### Config Generation

- Generate `litefs.yml` from Django settings at runtime
- Store generated config in temp directory or `DATA_PATH`
- Validate settings on Django startup

## Package Structure (Clean Architecture)

```
django-litefs/
├── pyproject.toml
├── README.md
├── CLAUDE.md
├── src/
│   └── django_litefs/
│       ├── __init__.py
│       ├── apps.py                    # [Framework] AppConfig startup hooks
│       │
│       ├── domain/                    # [Entities] Zero external deps
│       │   ├── __init__.py
│       │   ├── settings.py            # LiteFSSettings dataclass
│       │   ├── config.py              # ClusterConfig, DatabaseConfig
│       │   └── exceptions.py          # Domain exceptions
│       │
│       ├── usecases/                  # [Use Cases] Application logic
│       │   ├── __init__.py
│       │   ├── process_manager.py     # Start/stop/supervise LiteFS
│       │   ├── config_generator.py    # Generate litefs.yml
│       │   ├── health_checker.py      # Check replica status
│       │   └── primary_detector.py    # Detect primary node
│       │
│       ├── adapters/                  # [Interface Adapters]
│       │   ├── __init__.py
│       │   ├── django_settings.py     # Read from Django settings
│       │   └── subprocess_runner.py   # Run LiteFS binary
│       │
│       ├── db/                        # [Interface Adapters] Django backend
│       │   └── backends/
│       │       └── litefs/
│       │           ├── __init__.py
│       │           ├── base.py        # DatabaseWrapper
│       │           ├── features.py    # DatabaseFeatures
│       │           └── operations.py
│       │
│       ├── management/                # [Interface Adapters] Commands
│       │   └── commands/
│       │       ├── litefs_start.py
│       │       ├── litefs_status.py
│       │       └── litefs_primary.py
│       │
│       └── bin/                       # [Framework] Bundled binaries
│           └── .gitkeep
│
├── tests/
│   ├── conftest.py
│   ├── unit/
│   │   ├── domain/
│   │   │   └── test_settings.py
│   │   └── usecases/
│   │       ├── test_config_generator.py
│   │       └── test_process_manager.py
│   └── integration/
│       ├── test_backend.py
│       └── test_replication.py
└── scripts/
    └── download_litefs.py             # CI script to fetch binaries
```

## Adapter Resource Management

Adapters that manage resources (subprocesses, file handles) should implement the context manager protocol to ensure proper cleanup:

```python
class ProcessRunner:
    def __init__(self):
        self._process = None

    def __enter__(self) -> ProcessRunner:
        return self

    def __exit__(self, exc_type, exc_val, exc_tb) -> None:
        self.stop()

    def stop(self) -> None:
        if self._process:
            self._process.terminate()
            self._process.wait()
            self._process = None
```

## Port Method Signatures

Port methods should accept **primitive types**, not Django model instances:

```python
# ❌ Wrong - port depends on Django
class ConfigPort(Protocol):
    def generate(self, settings: django.conf.Settings) -> str: ...

# ✅ Right - port accepts domain types
class ConfigPort(Protocol):
    def generate(self, settings: LiteFSSettings) -> str: ...
```

## Open Questions

- [ ] Exact LiteFS version to bundle initially
- [ ] Development mode: single-node with no lease requirement, or mock LiteFS?
- [ ] Fly.io lease integration: worth including if trivial?

## Build Commands

```bash
# Install dependencies
uv sync

# Run all tests (excludes integration by default)
uv run pytest

# Run specific test category
uv run pytest -m unit
uv run pytest -m integration
uv run pytest -m property

# Type checking
uv run mypy src/django_litefs/

# Linting
uv run ruff check src/django_litefs/
uv run ruff format src/django_litefs/

# Build wheels
uv run python -m build
```

### Package Management (uv only)

**Never edit `pyproject.toml` dependencies directly.** Always use uv commands:

```bash
uv add requests              # Add dependency
uv add --group dev pytest    # Add dev dependency
uv remove requests           # Remove dependency
uv lock                      # Update lock file
```

## Balancing Abstraction vs Coupling

Clean Architecture can lead to over-engineering. Use these indicators:

### Signs of unnecessary indirection

- A port with only one adapter that will never have another
- Wrapper classes that just delegate to another class
- Interfaces with a single method that could be a function
- "Manager", "Handler", "Processor" classes that don't manage state
- More than 3 layers between API request and storage

### Signs of problematic coupling

- Domain importing from `adapters/`
- Use cases importing Django
- Tests requiring LiteFS binary to run
- Changing a domain model requires updating more than 3 files

### Rules of thumb

- **No port without 2+ adapters** (or clear intent for future adapters)
- **Prefer functions over classes** for stateless operations
- **Adapters should be thin** - convert types and delegate, not implement logic
- **If unsure, start concrete** - extract abstraction when the second use case appears

## Testing Strategy

### Test Organization

```bash
# By category
pytest -m unit           # Fast, no LiteFS process
pytest -m integration    # With Docker + FUSE
pytest -m property       # Property-based tests
```

### Test Directory Structure

```
tests/
├── unit/                    # No I/O, no subprocess
│   ├── domain/              # Pure domain logic (settings, config)
│   ├── usecases/            # Use case tests with in-memory adapters
│   └── conftest.py          # In-memory adapter fixtures
├── integration/             # Requires Docker + FUSE
│   ├── test_backend.py
│   └── test_replication.py
└── conftest.py              # Shared fixtures
```

### CI Strategy

- **Unit tests**: Run on all PRs (fast, no Docker)
- **Integration tests**: Run on main branch only (requires Docker + FUSE)
- **Local testing**: Docker Compose setup mirrors integration CI

### Test Isolation Rules

**Unit tests (`tests/unit/`) must NOT:**

- Spawn subprocesses or call LiteFS binary
- Access filesystem beyond temp directories
- Require FUSE or Docker

**Unit tests SHOULD use:**

- In-memory adapter fixtures:
  - `in_memory_process_runner` → `InMemoryProcessRunner`
  - `in_memory_config_writer` → `InMemoryConfigWriter`
  - `fake_primary_detector` → `FakePrimaryDetector`

### In-Memory Adapter Pattern

```python
# tests/unit/conftest.py
@pytest.fixture
def in_memory_process_runner():
    return InMemoryProcessRunner()

# tests/unit/usecases/test_process_manager.py
def test_start_litefs(in_memory_process_runner):
    manager = ProcessManager(runner=in_memory_process_runner)
    manager.start()
    assert in_memory_process_runner.started is True
```

### Property-Based Testing (Hypothesis)

Use for config generation and settings validation:

```bash
uv run pytest -m property -v
```

**When to use:**
| Pattern | Property to Test | Example |
|---------|-----------------|---------|
| **Round-trip** | `parse(generate(x)) == x` | Config YAML generation |
| **Invariants** | Bounds always hold | Path validation |
| **Idempotence** | `f(f(x)) == f(x)` | Settings normalization |

```python
from hypothesis import given, strategies as st

@pytest.mark.property
@given(mount_path=st.text(min_size=1).filter(lambda x: x.startswith("/")))
def test_config_includes_mount_path(mount_path):
    settings = LiteFSSettings(mount_path=mount_path)
    config = ConfigGenerator().generate(settings)
    assert mount_path in config
```

## Pre-commit Hooks

```bash
uv run pre-commit install    # Install hooks
uv run pre-commit run --all-files  # Run manually
```

Hooks mirror CI: ruff check, ruff format, mypy, pytest.

**NEVER bypass pre-commit hooks with `--no-verify`.** If a hook fails:

1. Fix the issue if it's a legitimate code problem
2. Report the error if it's a hook configuration issue

## CI Parity

**CI must use identical commands to local development.** No separate CI-specific scripts. The pipeline uses `uv sync` and `uv run` exactly as developers do locally.

## References

- [LiteFS Documentation](https://fly.io/docs/litefs/)
- [LiteFS GitHub](https://github.com/superfly/litefs)
- [Django Custom Database Backends](https://docs.djangoproject.com/en/5.2/ref/databases/#subclassing-the-built-in-database-backends)
